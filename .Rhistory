# 4. Modèle AFD
data_afd <- data.frame(Occupation = OS_propre, proportions_propres)
modele_afd <- lda(Occupation ~ ., data = data_afd)
pred_afd <- predict(modele_afd)
# 5. Évaluation (Matrice de confusion)
table_confusion <- table(Observé = data_afd$Occupation, Prédit = pred_afd$class)
taux_reussite <- sum(diag(table_confusion)) / sum(table_confusion) * 100
print("=== MATRICE DE CONFUSION (Prédiction Forêt/Agri/Ville) ===")
print(table_confusion)
cat("\n=> Taux de réussite du modèle bio-indicateur :", round(taux_reussite, 2), "%\n")
# 6. LE GRAPHIQUE "WAOUH" (s.class)
# Au lieu d'un nuage illisible, s.class trace le barycentre des groupes avec des ellipses
s.class(pred_afd$x, fac = data_afd$Occupation,
col = c("gold", "red", "forestgreen"),
cstar = 1,        # Relie les points au centre
cellipse = 1.5,   # Taille des ellipses de confiance
axesell = FALSE,  # Enlève la croix à l'intérieur des ellipses
grid = FALSE,
clabel = 1.2,     # Taille du texte
main = paste("AFD : L'impact de l'Homme sur le profil des poissons\n(Taux de réussite :", round(taux_reussite, 1), "%)"))
# 6. LE GRAPHIQUE "WAOUH" (s.class)
# Au lieu d'un nuage illisible, s.class trace le barycentre des groupes avec des ellipses
s.class(pred_afd$x, fac = data_afd$Occupation,
col = c("gold", "red", "forestgreen"),
cstar = 1,        # Relie les points au centre
cellipse = 1.5,   # Taille des ellipses de confiance
axesell = FALSE,  # Enlève la croix à l'intérieur des ellipses
grid = FALSE,
clabel = 1.2,     # Taille du texte
, round(taux_reussite, 1), "%)"))
# 6. LE GRAPHIQUE "WAOUH" (s.class)
# Au lieu d'un nuage illisible, s.class trace le barycentre des groupes avec des ellipses
s.class(pred_afd$x, fac = data_afd$Occupation,
col = c("gold", "red", "forestgreen"),
cstar = 1,        # Relie les points au centre
cellipse = 1.5,   # Taille des ellipses de confiance
axesell = FALSE,  # Enlève la croix à l'intérieur des ellipses
grid = FALSE,
clabel = 1.2,     # Taille du texte
round(taux_reussite, 1), "%)"))
# 6. LE GRAPHIQUE "WAOUH" (s.class)
# Au lieu d'un nuage illisible, s.class trace le barycentre des groupes avec des ellipses
s.class(pred_afd$x, fac = data_afd$Occupation,
col = c("gold", "red", "forestgreen"),
cstar = 1,        # Relie les points au centre
cellipse = 1.5,   # Taille des ellipses de confiance
axesell = FALSE,  # Enlève la croix à l'intérieur des ellipses
grid = FALSE,
clabel = 1.2)
# --- 1. VISUALISATION MULTIVARIÉE SUR LA CO-INERTIE ---
# La co-inertie a calculé les coordonnées des stations ("lX" et "lY").
# On va afficher ces stations et tracer des ellipses autour des Occupations du Sol (OS)
filtre_OS <- env$OS != "WATB" # On cache l'eau (2 stations) pour le graphe
OS_propre <- droplevels(as.factor(env$OS[filtre_OS]))
coord_coia <- coia_syndrome$lX[filtre_OS, ]
s.class(coord_coia, fac = OS_propre,
col = c("gold", "red", "forestgreen"),
cstar = 1, cellipse = 1.5, axesell = FALSE,
main = "Co-inertie : Séparation des milieux forestiers et agricoles")
# --- 2. VISUALISATION BIOLOGIQUE (Boxplots des Proportions) ---
# On calcule le pourcentage de chaque profil dans chaque rivière
matrice_appartenance <- model.matrix(~ 0 + Profil, data = traits)
s.class(coord_coia, fac = OS_propre,
col = c("gold", "red", "forestgreen"),
cstar = 1, cellipse = 1.5, axesell = FALSE)
# --- 2. VISUALISATION BIOLOGIQUE (Boxplots des Proportions) ---
# On calcule le pourcentage de chaque profil dans chaque rivière
matrice_appartenance <- model.matrix(~ 0 + Profil, data = traits)
colnames(matrice_appartenance) <- paste0("Profil_", levels(traits$Profil))
abondance_profils <- as.data.frame(as.matrix(sp) %*% matrice_appartenance)
proportions_profils <- (abondance_profils / rowSums(abondance_profils)) * 100 # En %
donnees_visu <- data.frame(OS = OS_propre, proportions_profils[filtre_OS, ])
par(mfrow = c(1, 2)) # On met les deux graphiques côte à côte
# Graphe des Perdants (Espèces vulnérables)
boxplot(Profil_1 ~ OS, data = donnees_visu,
col = c("gold", "red", "forestgreen"),
main = "Espèces Vulnérables ('Perdants')",
ylab = "Proportion dans la communauté (%)",
xlab = "Occupation du sol")
# Graphe des Gagnants (Espèces opportunistes)
boxplot(Profil_3 ~ OS, data = donnees_visu,
col = c("gold", "red", "forestgreen"),
main = "Espèces Opportunistes ('Gagnants')",
ylab = "Proportion dans la communauté (%)",
xlab = "Occupation du sol")
par(mfrow = c(1, 1))
library(ade4)
library(MASS)
# ==============================================================================
# ÉTAPE 0 : PRÉPARATION DES DONNÉES
# ==============================================================================
env <- read.csv("env.csv", sep=";", row.names=1)
sp <- read.csv("sp.csv", sep=";", row.names=1)
traits <- read.csv("traits.csv", sep=";", row.names=1)
# Nettoyage des zéros absolus
sp <- sp[, colSums(sp) > 0]
sp <- sp[rowSums(sp) > 0, ]
env <- env[rownames(sp), ]
# 1. ENVIRONNEMENT : Uniquement la géométrie de la rivière
env_phys <- env[, c("ALT", "DIST", "BV", "LARG", "PROF")]
env_phys_log <- log(env_phys + 1)
# 2. TRAITS : Respiration, Température, Reproduction et Habitat
traits_cibles <- traits[, c("REPRO", "OXY", "TEMP", "HAB")]
traits_cibles <- as.data.frame(lapply(traits_cibles, as.factor))
# ==============================================================================
# ÉTAPE 1 : LA ZONATION DE LA RIVIÈRE (ACP + CAH)
# ==============================================================================
pca_env <- dudi.pca(env_phys_log, center = TRUE, scale = TRUE, scannf = FALSE, nf = 2)
dist_env <- dist(pca_env$li)
cah_env <- hclust(dist_env, method = "ward.D2")
env$Zone_Riviere <- as.factor(cutree(cah_env, k = 3))
# Renommer les zones pour l'affichage (vérifie ton arbre pour l'ordre exact !)
noms_zones <- c("1_Amont (Torrents)", "2_Zone Intermédiaire", "3_Aval (Grands Fleuves)")
levels(env$Zone_Riviere) <- noms_zones
# ==============================================================================
# ÉTAPE 2 : LES PROFILS RESPIRATOIRES ET REPRODUCTIFS (ACM + CAH)
# ==============================================================================
acm_traits <- dudi.acm(traits_cibles, scannf = FALSE, nf = 2)
dist_traits <- dist(acm_traits$li)
cah_traits <- hclust(dist_traits, method = "ward.D2")
traits$Guilde <- as.factor(cutree(cah_traits, k = 3))
# Affichage des deux CAH sans titres
par(mfrow = c(1, 2))
plot(cah_env, labels = FALSE, xlab = "", sub = "")
rect.hclust(cah_env, k = 3, border = c("blue", "green", "red"))
plot(cah_traits, labels = traits$CODE_SP, cex = 0.6, xlab = "", sub = "")
rect.hclust(cah_traits, k = 3, border = c("blue", "green", "red"))
par(mfrow = c(1, 1))
# ==============================================================================
# ÉTAPE 3 : L'EFFET GUTTMAN (AFC)
# ==============================================================================
afc_sp <- dudi.coa(sp, scannf = FALSE, nf = 2)
# ==============================================================================
# ÉTAPE 4 : LA PREUVE DU FILTRE (Co-inertie)
# ==============================================================================
pca_env_pondd <- dudi.pca(env_phys_log, row.w = afc_sp$lw, center = TRUE, scale = TRUE, scannf = FALSE, nf = 2)
coia <- coinertia(pca_env_pondd, afc_sp, scannf = FALSE, nf = 2)
test_coia <- randtest(coia, nrepet = 999)
print("=== SIGNIFICATIVITÉ DU LIEN MILIEU / POISSONS ===")
print(test_coia)
# 1. Calcul des proportions
matrice_appartenance <- model.matrix(~ 0 + Guilde, data = traits)
colnames(matrice_appartenance) <- paste0("Guilde_", levels(traits$Guilde))
abondance_guildes <- as.data.frame(as.matrix(sp) %*% matrice_appartenance)
proportions_guildes <- (abondance_guildes / rowSums(abondance_guildes)) * 100
data_visu <- data.frame(Zone = env$Zone_Riviere, proportions_guildes)
# --- GRAPHIQUE 1 : L'Escalier Écologique (Boxplots sans titres) ---
par(mfrow = c(1, 2))
boxplot(Guilde_1 ~ Zone, data = data_visu,
col = "lightblue",
ylab = "Proportion dans la rivière (%)",
las = 2, cex.axis = 0.8)
boxplot(Guilde_3 ~ Zone, data = data_visu,
col = "darkseagreen",
ylab = "Proportion dans la rivière (%)",
las = 2, cex.axis = 0.8)
par(mfrow = c(1, 1))
# --- GRAPHIQUE 2 : L'AFD (Sans titre) ---
modele_afd <- lda(Zone ~ ., data = data_visu)
pred_afd <- predict(modele_afd)
table_confusion <- table(Observé = data_visu$Zone, Prédit = pred_afd$class)
taux_reussite <- sum(diag(table_confusion)) / sum(table_confusion) * 100
print("=== MATRICE DE CONFUSION ===")
print(table_confusion)
cat("\n=> Taux de réussite de l'AFD :", round(taux_reussite, 2), "%\n")
s.class(pred_afd$x, fac = data_visu$Zone,
col = c("blue", "green4", "red"),
cstar = 1, cellipse = 1.5, axesell = FALSE, clabel = 0.8)
source("~/.active-rstudio-document")
par(mfrow = c(1, 2))
# 1. On projette les espèces colorées par leur exigence en OXYGÈNE
s.class(coia$c1, fac = traits$OXY,
col = c("blue", "red"), # Bleu = Intolérant, Rouge = Tolérant
cstar = 1, cellipse = 1.5, axesell = FALSE, clabel = 1.2)
# 2. On projette les espèces colorées par leur type de REPRODUCTION
s.class(coia$c1, fac = traits$REPRO,
col = c("darkgreen", "purple"), # Ex: Vert = Courant (RH), Violet = Stagnant (LI)
cstar = 1, cellipse = 1.5, axesell = FALSE, clabel = 1.2)
par(mfrow = c(1, 1))
library(ade4)
# ==============================================================================
# ÉTAPE 0 : PRÉPARATION DES DONNÉES
# ==============================================================================
env <- read.csv("env.csv", sep=";", row.names=1)
sp <- read.csv("sp.csv", sep=";", row.names=1)
traits <- read.csv("traits.csv", sep=";", row.names=1)
# Nettoyage
sp <- sp[, colSums(sp) > 0]
sp <- sp[rowSums(sp) > 0, ]
env <- env[rownames(sp), ]
# Variables physiques (le continuum)
env_phys <- env[, c("ALT", "DIST", "BV", "LARG", "PROF")]
env_phys_log <- log(env_phys + 1)
# Traits biologiques (respiration, reproduction, température)
traits_cibles <- traits[, c("REPRO", "OXY", "TEMP")]
traits_cibles <- as.data.frame(lapply(traits_cibles, as.factor))
# ==============================================================================
# ÉTAPE 1 : LE CONTINUUM PHYSIQUE (ACP)
# ==============================================================================
pca_env <- dudi.pca(env_phys_log, center = TRUE, scale = TRUE, scannf = FALSE, nf = 2)
# Graphique : Cercle des corrélations (Axe 1 = Le fameux gradient amont-aval)
s.corcircle(pca_env$co, clabel = 0.8)
# ==============================================================================
# ÉTAPE 2 : LE PROFIL DES TRAITS (ACM)
# ==============================================================================
acm_traits <- dudi.acm(traits_cibles, scannf = FALSE, nf = 2)
# Graphique : Les modalités des traits
s.label(acm_traits$co, clabel = 0.8)
# ==============================================================================
# ÉTAPE 3 : LE TURNOVER SPÉCIFIQUE (AFC)
# ==============================================================================
afc_sp <- dudi.coa(sp, scannf = FALSE, nf = 2)
# ==============================================================================
# ÉTAPE 4 : LE COUPLAGE (Co-inertie)
# ==============================================================================
# On refait l'ACP avec les poids des stations issus de l'AFC
pca_env_pondd <- dudi.pca(env_phys_log, row.w = afc_sp$lw, center = TRUE, scale = TRUE, scannf = FALSE, nf = 2)
# Analyse de Co-inertie
coia <- coinertia(pca_env_pondd, afc_sp, scannf = FALSE, nf = 2)
# Test statistique de Monte-Carlo
test_coia <- randtest(coia, nrepet = 999)
print(test_coia) # Vérifier la p-value
par(mfrow = c(1, 2))
# 1. On projette les espèces colorées par leur exigence en OXYGÈNE
s.class(coia$c1, fac = traits$OXY,
col = c("blue", "red"), # Bleu = Intolérant, Rouge = Tolérant
cstar = 1, cellipse = 1.5, axesell = FALSE, clabel = 1.2)
library(ade4)
# ==============================================================================
# ÉTAPE 0 : PRÉPARATION DES DONNÉES
# ==============================================================================
env <- read.csv("env.csv", sep=";", row.names=1)
sp <- read.csv("sp.csv", sep=";", row.names=1)
traits <- read.csv("traits.csv", sep=";", row.names=1)
# Nettoyage des zéros absolus
sp <- sp[, colSums(sp) > 0]
sp <- sp[rowSums(sp) > 0, ]
env <- env[rownames(sp), ]
# Variables environnementales (transformation log sur la morphologie)
env_quant <- env[, c("TEMP", "MTC", "MTW", "PREC", "BV", "DIST", "ALT", "LARG", "PROF")]
env_quant$BV   <- log(env_quant$BV + 1)
env_quant$DIST <- log(env_quant$DIST + 1)
env_quant$ALT  <- log(env_quant$ALT + 1)
env_quant$LARG <- log(env_quant$LARG + 1)
env_quant$PROF <- log(env_quant$PROF + 1)
# Traits ciblés sur la VULNÉRABILITÉ
traits_vuln <- traits[, c("QUAL", "HAB", "OXY", "TEMP", "STATUT")]
traits_vuln <- as.data.frame(lapply(traits_vuln, as.factor))
# ==============================================================================
# ÉTAPE 1 : LE PORTRAIT DES GAGNANTS ET PERDANTS (ACM + CAH)
# ==============================================================================
acm_vuln <- dudi.acm(traits_vuln, scannf = FALSE, nf = 2)
dist_vuln <- dist(acm_vuln$li)
cah_vuln <- hclust(dist_vuln, method = "ward.D2")
traits$Profil <- as.factor(cutree(cah_vuln, k = 3))
par(mfrow = c(1, 2))
s.label(acm_vuln$co, clabel = 0.8)
plot(cah_vuln, labels = rownames(traits), cex = 0.6, xlab = "", sub = "")
rect.hclust(cah_vuln, k = 3, border = c("red", "orange", "green3"))
par(mfrow = c(1, 1))
# ==============================================================================
# ÉTAPE 2 : LE SYNDROME ANTHROPIQUE DU MILIEU (ACP)
# ==============================================================================
pca_env <- dudi.pca(env_quant, center = TRUE, scale = TRUE, scannf = FALSE, nf = 2)
# Projection de l'Occupation du Sol sur l'ACP environnementale
s.class(pca_env$li, fac = as.factor(env$OS),
col = c("gold", "red", "forestgreen", "blue"),
cstar = 1, cellipse = 1.5, axesell = FALSE, clabel = 0.8)
# ==============================================================================
# ÉTAPE 3 : LE TURNOVER SPÉCIFIQUE (AFC)
# ==============================================================================
afc_sp <- dudi.coa(sp, scannf = FALSE, nf = 2)
# ==============================================================================
# ÉTAPE 4 : LA PREUVE DU FILTRE ANTHROPIQUE (CO-INERTIE)
# ==============================================================================
pca_env_pondd <- dudi.pca(env_quant, row.w = afc_sp$lw, center = TRUE, scale = TRUE, scannf = FALSE, nf = 2)
coia_syndrome <- coinertia(pca_env_pondd, afc_sp, scannf = FALSE, nf = 2)
test_coia <- randtest(coia_syndrome, nrepet = 999)
print("=== TEST DE CO-INERTIE ===")
print(test_coia)
# Visualisation globale des flèches de co-inertie
plot(coia_syndrome)
# 1. Nettoyage de la modalité "WATB" (Surfaces en eau, trop rares)
filtre_OS <- env$OS != "WATB"
OS_propre <- droplevels(as.factor(env$OS[filtre_OS]))
# 2. Calcul des PROPORTIONS de chaque profil par station
matrice_appartenance <- model.matrix(~ 0 + Profil, data = traits)
colnames(matrice_appartenance) <- paste0("Profil_", levels(traits$Profil))
abondance_profils <- as.data.frame(as.matrix(sp) %*% matrice_appartenance)
proportions_profils <- (abondance_profils / rowSums(abondance_profils)) * 100
data_visu <- data.frame(OS = OS_propre, proportions_profils[filtre_OS, ])
# --- VISUALISATION 1 : La Co-inertie selon l'Occupation du Sol ---
# L'axe de la co-inertie sépare-t-il les milieux forestiers des milieux agricoles ?
coord_coia <- coia_syndrome$lX[filtre_OS, ]
s.class(coord_coia, fac = OS_propre,
col = c("gold", "red", "forestgreen"),
cstar = 1, cellipse = 1.5, axesell = FALSE, clabel = 1)
par(mfrow = c(1, 2))
# Boxplot pour les "Perdants" (Espèces sensibles)
boxplot(Profil_1 ~ OS, data = data_visu,
col = c("gold", "red", "forestgreen"),
ylab = "Proportion dans la communauté (%)",
xlab = "Occupation du sol",
las = 1)
# Boxplot pour les "Gagnants" (Espèces opportunistes/exotiques)
boxplot(Profil_3 ~ OS, data = data_visu,
col = c("gold", "red", "forestgreen"),
ylab = "Proportion dans la communauté (%)",
xlab = "Occupation du sol",
las = 1)
par(mfrow = c(1, 1))
# 1. Extraction des coordonnées spatiales (en gardant le filtre pour enlever WATB)
xy <- env[filtre_OS, c("X", "Y")]
par(mfrow = c(1, 2))
# --- CARTE 1 : L'occupation du sol dans l'espace ---
# On projette les X et Y. cstar=0 et cellipse=0 permettent de n'afficher que les points purs.
s.class(xy, fac = OS_propre,
col = c("gold", "red", "forestgreen"),
cstar = 0, cellipse = 0, axesell = FALSE, grid = FALSE,
xlab = "", ylab = "", sub = "")
# --- CARTE 2 : La répartition géographique des poissons "Gagnants" ---
# La fonction s.value dessine des carrés (positifs) ou cercles (négatifs)
# dont la taille est proportionnelle au pourcentage de la guilde.
# ATTENTION : Remplace "Profil_3" par le bon numéro de tes Gagnants !
s.value(xy, data_visu$Profil_3,
grid = FALSE, xlab = "", ylab = "", sub = "",
csize = 0.5) # csize règle la taille des carrés
par(mfrow = c(1, 1))
# --- CARTE 1 : L'occupation du sol dans l'espace ---
# On projette les X et Y. cstar=0 et cellipse=0 permettent de n'afficher que les points purs.
col = c("gold", "red", "forestgreen"),
# --- CARTE 1 : L'occupation du sol dans l'espace ---
# On projette les X et Y. cstar=0 et cellipse=0 permettent de n'afficher que les points purs.
s.class(xy, fac = OS_propre,
col = c("gold", "red", "forestgreen"),
cstar = 0, cellipse = 0, axesell = FALSE, grid = FALSE)
# --- CARTE 2 : La répartition géographique des poissons "Gagnants" ---
# La fonction s.value dessine des carrés (positifs) ou cercles (négatifs)
# dont la taille est proportionnelle au pourcentage de la guilde.
# ATTENTION : Remplace "Profil_3" par le bon numéro de tes Gagnants !
s.value(xy, data_visu$Profil_3,
grid = FALSE, xlab = "", ylab = "", sub = "",
csize = 0.5) # csize règle la taille des carrés
# --- CARTE 2 : La répartition géographique des poissons "Gagnants" ---
# La fonction s.value dessine des carrés (positifs) ou cercles (négatifs)
# dont la taille est proportionnelle au pourcentage de la guilde.
# ATTENTION : Remplace "Profil_3" par le bon numéro de tes Gagnants !
s.value(xy, data_visu$Profil_3,
grid = FALSE,
csize = 0.5) # csize règle la taille des carrés
par(mfrow = c(1, 2))
# Boxplot pour les "Perdants" (Espèces sensibles)
boxplot(Profil_1 ~ OS, data = data_visu,
col = c("gold", "red", "forestgreen"),
ylab = "Proportion dans la communauté (%)",
xlab = "Occupation du sol",
las = 1)
# Boxplot pour les "Gagnants" (Espèces opportunistes/exotiques)
boxplot(Profil_3 ~ OS, data = data_visu,
col = c("gold", "red", "forestgreen"),
ylab = "Proportion dans la communauté (%)",
xlab = "Occupation du sol",
las = 1)
test_coia <- randtest(coia_syndrome, nrepet = 999)
print("=== TEST DE CO-INERTIE ===")
print(test_coia)
# ==============================================================================
# ÉTAPE 1 : LE PORTRAIT DES GAGNANTS ET PERDANTS (ACM + CAH)
# ==============================================================================
acm_vuln <- dudi.acm(traits_vuln, scannf = FALSE, nf = 2)
dist_vuln <- dist(acm_vuln$li)
cah_vuln <- hclust(dist_vuln, method = "ward.D2")
traits$Profil <- as.factor(cutree(cah_vuln, k = 3))
par(mfrow = c(1, 2))
s.label(acm_vuln$co, clabel = 0.8)
plot(cah_vuln, labels = rownames(traits), cex = 0.6, xlab = "", sub = "")
rect.hclust(cah_vuln, k = 3, border = c("red", "orange", "green3"))
par(mfrow = c(1, 1))
s.class(xy, fac = OS_propre,
col = c("gold", "red", "forestgreen"),
cstar = 0, cellipse = 0, axesell = FALSE, grid = FALSE)
s.value(xy, data_visu$Profil_3,
grid = FALSE,
csize = 0.5) # csize règle la taille des carrés
# --- CARTE 1 : L'occupation du sol dans l'espace ---
# On projette les X et Y. cstar=0 et cellipse=0 permettent de n'afficher que les points purs.
s.class(xy, fac = OS_propre,
col = c("gold", "red", "forestgreen"),
cstar = 0, cellipse = 0, axesell = FALSE)
# --- CARTE 2 : La répartition géographique des poissons "Gagnants" ---
# La fonction s.value dessine des carrés (positifs) ou cercles (négatifs)
# dont la taille est proportionnelle au pourcentage de la guilde.
# ATTENTION : Remplace "Profil_3" par le bon numéro de tes Gagnants !
s.value(xy, data_visu$Profil_3,
grid = FALSE,
csize = 0.5) # csize règle la taille des carrés
# --- CARTE 1 : L'occupation du sol dans l'espace ---
# On projette les X et Y. cstar=0 et cellipse=0 permettent de n'afficher que les points purs.
par(mfrow=c(1,2))
s.class(xy, fac = OS_propre,
col = c("gold", "red", "forestgreen"),
cstar = 0, cellipse = 0, axesell = FALSE, grid = FALSE)
# --- CARTE 2 : La répartition géographique des poissons "Gagnants" ---
# La fonction s.value dessine des carrés (positifs) ou cercles (négatifs)
# dont la taille est proportionnelle au pourcentage de la guilde.
# ATTENTION : Remplace "Profil_3" par le bon numéro de tes Gagnants !
s.value(xy, data_visu$Profil_3,
grid = FALSE,
csize = 0.5) # csize règle la taille des carrés
par(mfrow = c(1, 1))
library(ade4)
# ==============================================================================
# ÉTAPE 0 : PRÉPARATION DES DONNÉES
# ==============================================================================
env <- read.csv("env.csv", sep=";", row.names=1)
sp <- read.csv("sp.csv", sep=";", row.names=1)
traits <- read.csv("traits.csv", sep=";", row.names=1)
# Nettoyage des zéros absolus
sp <- sp[, colSums(sp) > 0]
sp <- sp[rowSums(sp) > 0, ]
env <- env[rownames(sp), ]
# Variables environnementales (transformation log sur la morphologie)
env_quant <- env[, c("TEMP", "MTC", "MTW", "PREC", "BV", "DIST", "ALT", "LARG", "PROF")]
env_quant$BV   <- log(env_quant$BV + 1)
env_quant$DIST <- log(env_quant$DIST + 1)
env_quant$ALT  <- log(env_quant$ALT + 1)
env_quant$LARG <- log(env_quant$LARG + 1)
env_quant$PROF <- log(env_quant$PROF + 1)
# Traits ciblés sur la VULNÉRABILITÉ
traits_vuln <- traits[, c("QUAL", "HAB", "OXY", "TEMP", "STATUT")]
traits_vuln <- as.data.frame(lapply(traits_vuln, as.factor))
# ==============================================================================
# ÉTAPE 1 : LE PORTRAIT DES GAGNANTS ET PERDANTS (ACM + CAH)
# ==============================================================================
acm_vuln <- dudi.acm(traits_vuln, scannf = FALSE, nf = 2)
dist_vuln <- dist(acm_vuln$li)
cah_vuln <- hclust(dist_vuln, method = "ward.D2")
traits$Profil <- as.factor(cutree(cah_vuln, k = 3))
par(mfrow = c(1, 2))
s.label(acm_vuln$co, clabel = 0.8)
plot(cah_vuln, labels = rownames(traits), cex = 0.6, xlab = "", sub = "")
rect.hclust(cah_vuln, k = 3, border = c("red", "orange", "green3"))
par(mfrow = c(1, 1))
# ==============================================================================
# ÉTAPE 2 : LE SYNDROME ANTHROPIQUE DU MILIEU (ACP)
# ==============================================================================
pca_env <- dudi.pca(env_quant, center = TRUE, scale = TRUE, scannf = FALSE, nf = 2)
# Projection de l'Occupation du Sol sur l'ACP environnementale
s.class(pca_env$li, fac = as.factor(env$OS),
col = c("gold", "red", "forestgreen", "blue"),
cstar = 1, cellipse = 1.5, axesell = FALSE, clabel = 0.8)
# ==============================================================================
# ÉTAPE 3 : LE TURNOVER SPÉCIFIQUE (AFC)
# ==============================================================================
afc_sp <- dudi.coa(sp, scannf = FALSE, nf = 2)
# ==============================================================================
# ÉTAPE 4 : LA PREUVE DU FILTRE ANTHROPIQUE (CO-INERTIE)
# ==============================================================================
pca_env_pondd <- dudi.pca(env_quant, row.w = afc_sp$lw, center = TRUE, scale = TRUE, scannf = FALSE, nf = 2)
coia_syndrome <- coinertia(pca_env_pondd, afc_sp, scannf = FALSE, nf = 2)
test_coia <- randtest(coia_syndrome, nrepet = 999)
print("=== TEST DE CO-INERTIE ===")
print(test_coia)
# Visualisation globale des flèches de co-inertie
plot(coia_syndrome)
# 1. Nettoyage de la modalité "WATB" (Surfaces en eau, trop rares)
filtre_OS <- env$OS != "WATB"
OS_propre <- droplevels(as.factor(env$OS[filtre_OS]))
# 2. Calcul des PROPORTIONS de chaque profil par station
matrice_appartenance <- model.matrix(~ 0 + Profil, data = traits)
colnames(matrice_appartenance) <- paste0("Profil_", levels(traits$Profil))
abondance_profils <- as.data.frame(as.matrix(sp) %*% matrice_appartenance)
proportions_profils <- (abondance_profils / rowSums(abondance_profils)) * 100
data_visu <- data.frame(OS = OS_propre, proportions_profils[filtre_OS, ])
# --- VISUALISATION 1 : La Co-inertie selon l'Occupation du Sol ---
# L'axe de la co-inertie sépare-t-il les milieux forestiers des milieux agricoles ?
coord_coia <- coia_syndrome$lX[filtre_OS, ]
s.class(coord_coia, fac = OS_propre,
col = c("gold", "red", "forestgreen"),
cstar = 1, cellipse = 1.5, axesell = FALSE, clabel = 1)
par(mfrow = c(1, 2))
# Boxplot pour les "Perdants" (Espèces sensibles)
boxplot(Profil_1 ~ OS, data = data_visu,
col = c("gold", "red", "forestgreen"),
ylab = "Proportion dans la communauté (%)",
xlab = "Occupation du sol",
las = 1)
# Boxplot pour les "Gagnants" (Espèces opportunistes/exotiques)
boxplot(Profil_3 ~ OS, data = data_visu,
col = c("gold", "red", "forestgreen"),
ylab = "Proportion dans la communauté (%)",
xlab = "Occupation du sol",
las = 1)
par(mfrow = c(1, 1))
# 1. Extraction des coordonnées spatiales (en gardant le filtre pour enlever WATB)
xy <- env[filtre_OS, c("X", "Y")]
par(mfrow = c(1, 2))
# --- CARTE 1 : L'occupation du sol dans l'espace ---
# On projette les X et Y. cstar=0 et cellipse=0 permettent de n'afficher que les points purs.
par(mfrow=c(1,2))
s.class(xy, fac = OS_propre,
col = c("gold", "red", "forestgreen"),
cstar = 0, cellipse = 0, axesell = FALSE, grid = FALSE)
# --- CARTE 2 : La répartition géographique des poissons "Gagnants" ---
# La fonction s.value dessine des carrés (positifs) ou cercles (négatifs)
# dont la taille est proportionnelle au pourcentage de la guilde.
# ATTENTION : Remplace "Profil_3" par le bon numéro de tes Gagnants !
s.value(xy, data_visu$Profil_3,
grid = FALSE,
csize = 0.5) # csize règle la taille des carrés
par(mfrow = c(1, 1))
q
